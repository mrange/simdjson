<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">README.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#  simdjson : Parsing gigabytes of JSON per second</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;[![Build Status](https://cloud.drone.io/api/badges/lemire/simdjson/status.svg)](https://cloud.drone.io/lemire/simdjson/)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;[![CircleCI](https://circleci.com/gh/lemire/simdjson.svg?style=svg)](https://circleci.com/gh/lemire/simdjson)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[![Build Status](https://img.shields.io/appveyor/ci/lemire/simdjson/master.svg)](https://ci.appveyor.com/project/lemire/simdjson)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;[![][license img]][license]</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdjson.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;can=1&amp;q=proj:simdjson)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## A C++ library to see how fast we can parse JSON with complete validation.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;JSON documents are everywhere on the Internet. Servers spend a lot of time parsing these documents. We want to accelerate the parsing of JSON per se using commonly available SIMD instructions as much as possible while doing full validation (including character encoding). This library is part of the [Awesome Modern C++](https://awesomecpp.com) list.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;&lt;img src=&quot;images/logo.png&quot; width=&quot;10%&quot;&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;## Real-world usage</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;- [Microsoft FishStore](https://github.com/microsoft/FishStore)</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;- [Yandex ClickHouse](https://github.com/yandex/ClickHouse)</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;If you are planning to use simdjson in a product, please work from one of our releases.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;## Research article (VLDB Journal)</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;A description of the design and implementation of simdjson is in our research article:</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;* Geoff Langdale, Daniel Lemire, [Parsing Gigabytes of JSON per Second](https://arxiv.org/abs/1902.08318), VLDB Journal 28 (6), 2019appear)</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;We also have an informal [blog post providing some background and context](https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/).</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;Some people [enjoy reading our paper](https://arxiv.org/abs/1902.08318):</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;[&lt;img src=&quot;images/halvarflake.png&quot; width=&quot;50%&quot;&gt;](https://twitter.com/halvarflake/status/1118459536686362625)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;## Talks</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;QCon San Francisco 2019 (best voted talk):</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;[![simdjson at QCon San Francisco 2019](http://img.youtube.com/vi/wlvKAT7SZIQ/0.jpg)](http://www.youtube.com/watch?v=wlvKAT7SZIQ)</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;## Performance results</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;simdjson uses three-quarters less instructions than state-of-the-art parser RapidJSON and fifty percent less than sajson. To our knowledge, simdjson is the first fully-validating JSON parser to run at gigabytes per second on commodity processors.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;&lt;img src=&quot;doc/gbps.png&quot; width=&quot;90%&quot;&gt;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;On a Skylake processor, the parsing speeds (in GB/s) of various processors on the twitter.json file are as follows.</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;| parser                                | GB/s |</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;| ------------------------------------- | ---- |</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;| simdjson                              | 2.2  |</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;| RapidJSON encoding-validation         | 0.51 |</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;| RapidJSON encoding-validation, insitu | 0.71 |</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;| sajson (insitu, dynamic)              | 0.70 |</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;| sajson (insitu, static)               | 0.97 |</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;| dropbox                               | 0.14 |</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;| fastjson                              | 0.26 |</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;| gason                                 | 0.85 |</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;| ultrajson                             | 0.42 |</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;| jsmn                                  | 0.28 |</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;| cJSON                                 | 0.34 |</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;| JSON for Modern C++ (nlohmann/json)   | 0.10 |</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;## Requirements</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;- We support 64-bit platforms like Linux or macOS, as well as Windows through Visual Studio 2017 or later.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;- A processor with</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  - AVX2 (i.e., Intel processors starting with the Haswell microarchitecture released 2013 and AMD processors starting with the Zen microarchitecture released 2017),</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  - or SSE 4.2 and CLMUL (i.e., Intel processors going back to Westmere released in 2010 or AMD processors starting with the Jaguar used in the PS4 and XBox One)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  - or a 64-bit ARM processor (ARMv8-A): this covers a wide range of mobile processors, including all Apple processors currently available for sale, going as far back as the iPhone 5s (2013).</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;- A recent C++ compiler (e.g., GNU GCC or LLVM CLANG or Visual Studio 2017), we assume C++17. GNU GCC 7 or better or LLVM&#39;s clang 6 or better.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;- Some benchmark scripts assume bash and other common utilities, but they are optional.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;## License</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;This code is made available under the Apache License 2.0.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;Under Windows, we build some tools using the windows/dirent_portable.h file (which is outside our library code): it under the liberal (business-friendly) MIT license.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;## Runtime dispatch</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;On Intel and AMD processors, we get best performance by using the hardware support for AVX2 instructions. However, simdjson also runs on older Intel and AMD processors. We require a minimum feature support of SSE 4.2 and CLMUL (2010 Intel Westmere or better). The code automatically detects the feature set of your processor and switches to the right function at runtime (a technique sometimes called runtime dispatch).</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;On x64 hardware, you should typically build your code by specifying the oldest/less-featureful system you want to support so that runtime dispatch may work. The minimum requirement for simdjson is the equivalent of a Westmere processor (SSE 4.2 and PCLMUL). If you build your code by asking the compiler to use more advanced instructions (e.g., `-mavx2`, `/AVX2`  or `-march=haswell`), then it will break runtime dispatch and your binaries will fail to run on older processors.</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;We also support 64-bit ARM. We assume NEON support. There is no runtime dispatch on ARM.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;If you expect your code to run on older processors, you can check that the CPU is supported as follows:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;```c++</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;if (simdjson::active_implementation-&gt;name() == &quot;unsupported&quot;) { </div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  printf(&quot;unsupported CPU\n&quot;); </div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;```</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;This check is not useful on ARM processors since all 64-bit ARM processors are supported.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;It is not necessary to do this check: if you omit it, you will get back the error code `UNSUPPORTED_ARCHITECTURE` when trying to parse documents.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;However, you can call `simdjson::active_implementation-&gt;name()` to check which CPU configuration has been detected (e.g., haswell, westmere).</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;## Computed GOTOs</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;For best performance, we use a technique called &quot;computed goto&quot;, it is also sometimes described as &quot;Labels as Values&quot;.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;Though it is not part of the C++ standard, it is supported by many major compilers and it brings measurable performance benefits that</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;are difficult to achieve otherwise.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;The computed gotos are  automatically disabled under Visual Studio.</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;If you wish to forcefully disable computed gotos, you can do so by compiling the code with the macro `SIMDJSON_NO_COMPUTED_GOTO`</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;defined. It is not recommended to disable computed gotos if your compiler supports it. In fact, you should almost never need to</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;be concerned with computed gotos.</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;## Thread safety</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;The simdjson library is mostly single-threaded. Thread safety is the responsability of the caller: it is unsafe to reuse a document::parser object between different threads.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;If you are on an x64 processor, the runtime dispatching assigns the right code path the first time that parsing is attempted. The runtime dispatching is thread-safe.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;The json stream parser is threaded, using exactly two threads. </div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;## Large files</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;If you are processing large files (e.g., 100 MB), it is likely that the performance of simdjson will be limited by page misses and/or page allocation. [On some systems, memory allocation runs far slower than we can parse (e.g., 1.4GB/s).](https://lemire.me/blog/2020/01/14/how-fast-can-you-allocate-a-large-block-of-memory-in-c/)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;You will get best performance with large or huge pages. Under Linux, you can enable transparent huge pages with a command like `echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled` (root access may be required). We recommend that you report performance numbers with and without huge pages. </div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;Another strategy is to reuse pre-allocated buffers. That is, you avoid reallocating memory. You just allocate memory once and reuse the blocks of memory.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;## Including simdjson</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;## Code usage and example</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;The main API involves allocating a `document::parser`, and calling `parser.parse()` to create a fully navigable document-object-model (DOM) view of a JSON document. The DOM can be accessed via [JSON Pointer](https://tools.ietf.org/html/rfc6901) paths, or as an iterator (`document::iterator(doc)`). See &#39;Navigating the parsed document&#39; for more.</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;All examples below use use `#include &quot;simdjson.h&quot;`, `#include &quot;simdjson.cpp&quot;` and `using namespace simdjson;`.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;The simplest API to get started is `document::parse()`, which allocates a new parser, parses a string, and returns the DOM. This is less efficient if you&#39;re going to read multiple documents, but as long as you&#39;re only parsing a single document, this will do just fine.</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;```c++</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;auto [doc, error] = document::parse(string(&quot;[ 1, 2, 3 ]&quot;));</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;if (error) { cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; error_meesage(error) &lt;&lt; endl; exit(1); }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;doc.print_json(cout);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;```</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;If you&#39;re using exceptions, it gets even simpler (simdjson won&#39;t use exceptions internally, so you&#39;ll only pay the performance cost of exceptions in your own calling code):</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```c++</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;document doc = document::parse(string(&quot;[ 1, 2, 3 ]&quot;));</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;doc.print_json(cout);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;```</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;The simdjson library requires SIMDJSON_PADDING extra bytes at the end of a string (it doesn&#39;t matter if the bytes are initialized). The `padded_string` class is an easy way to ensure this is accomplished up front and prevent the extra allocation:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;```c++</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;document doc = document::parse(padded_string(string(&quot;[ 1, 2, 3 ]&quot;)));</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;doc.print_json(cout);</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;```</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;You can also load from a file with `get_corpus`:</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```c++</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;document doc = document::parse(get_corpus(filename));</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;doc.print_json(cout);</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;```</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;If you&#39;re using simdjson to parse multiple documents, or in a loop, you should allocate a parser once and reuse it (allocation is slow, do it as little as possible!):</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;```c++</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;// Allocate a parser big enough for all files</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;document::parser parser;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;if (!parser.allocate_capacity(1024*1024)) { exit(1); }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;// Read files with the parser, one by one</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;for (padded_string json : { string(&quot;[1, 2, 3]&quot;), string(&quot;true&quot;), string(&quot;[ true, false ]&quot;) }) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  cout &lt;&lt; &quot;Parsing &quot; &lt;&lt; json.data() &lt;&lt; &quot; ...&quot; &lt;&lt; endl;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  auto [doc, error] = parser.parse(json);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  if (error) { cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; error_message(error) &lt;&lt; endl; exit(1); }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  doc.print_json(cout);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  cout &lt;&lt; endl;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;}</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;```</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;## Newline-Delimited JSON (ndjson) and  JSON lines </div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;The simdjson library also support multithreaded JSON streaming through a large file containing many smaller JSON documents in either [ndjson](http://ndjson.org) or [JSON lines](http://jsonlines.org) format. We support files larger than 4GB.</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;**API and detailed documentation found [here](doc/JsonStream.md).**</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;Here is a simple example, using single header simdjson:</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;```cpp</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;#include &quot;simdjson.h&quot;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;#include &quot;simdjson.cpp&quot;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;int parse_file(const char *filename) {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    simdjson::padded_string p = simdjson::get_corpus(filename);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    simdjson::document::parser parser;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    simdjson::JsonStream js{p};</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    int parse_res = simdjson::SUCCESS_AND_HAS_MORE;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    </div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    while (parse_res == simdjson::SUCCESS_AND_HAS_MORE) {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            parse_res = js.json_parse(parser);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            //Do something with parser...</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;}</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;```</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;## Usage: easy single-header version</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;See the &quot;singleheader&quot; repository for a single header version. See the included</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;file &quot;amalgamation_demo.cpp&quot; for usage. This requires no specific build system: just</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;copy the files in your project in your include path. You can then include them quite simply:</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;```c++</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;#include &quot;simdjson.h&quot;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;#include &quot;simdjson.cpp&quot;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;using namespace simdjson;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;int main(int argc, char *argv[]) {</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  const char * filename = argv[1];</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  padded_string p = get_corpus(filename);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  document::parser parser = build_parsed_json(p); // do the parsing</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  if( ! parser.is_valid() ) {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    std::cout &lt;&lt; &quot;not valid&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    std::cout &lt;&lt; parser.get_error_message() &lt;&lt; std::endl;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  } else {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    std::cout &lt;&lt; &quot;valid&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  return EXIT_SUCCESS;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;}</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;```</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;Note: In some settings, it might be desirable to precompile `simdjson.cpp` instead of including it.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;## Usage (old-school Makefile on platforms like Linux or macOS)</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;Requirements: recent clang or gcc, and make. We recommend at least GNU GCC/G++ 7 or LLVM clang 6. A 64-bit system like Linux or macOS is expected.</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;To test:</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;```</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;make</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;make test</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;```</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;To run benchmarks:</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;```</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;make parse</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;./parse jsonexamples/twitter.json</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;```</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;Under Linux, the `parse` command gives a detailed analysis of the performance counters.</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;To run comparative benchmarks (with other parsers):</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;```</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;make benchmark</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;```</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;## Usage (CMake on 64-bit platforms like Linux or macOS)</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;Requirements: We require a recent version of cmake. On macOS, the easiest way to install cmake might be to use [brew](https://brew.sh) and then type</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;```</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;brew install cmake</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;```</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;There is an [equivalent brew on Linux which works the same way as well](https://linuxbrew.sh).</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;You need a recent compiler like clang or gcc. We recommend at least GNU GCC/G++ 7 or LLVM clang 6. For example, you can install a recent compiler with brew:</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;```</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;brew install gcc@8</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;```</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;Optional: You need to tell cmake which compiler you wish to use by setting the CC and CXX variables. Under bash, you can do so with commands such as `export CC=gcc-7` and `export CXX=g++-7`.</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;Building: While in the project repository, do the following:</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;```</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;mkdir build</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;cd build</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;cmake ..</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;make</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;make test</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;```</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;CMake will build a library. By default, it builds a shared library (e.g., libsimdjson.so on Linux).</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;You can build a static library:</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;```</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;mkdir buildstatic</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;cd buildstatic</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;cmake -DSIMDJSON_BUILD_STATIC=ON ..</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;make</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;make test</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;```</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;In some cases, you may want to specify your compiler, especially if the default compiler on your system is too old. You may proceed as follows:</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;```</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;brew install gcc@8</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;mkdir build</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;cd build</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;export CXX=g++-8 CC=gcc-8</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;cmake ..</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;make</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;make test</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;```</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;## Usage (CMake on 64-bit Windows using Visual Studio)</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;We assume you have a common 64-bit Windows PC with at least Visual Studio 2017 and an x64 processor with AVX2 support (2013 Intel Haswell or later) or SSE 4.2 + CLMUL (2010 Westmere or later).</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;- Grab the simdjson code from GitHub, e.g., by cloning it using [GitHub Desktop](https://desktop.github.com/).</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;- Install [CMake](https://cmake.org/download/). When you install it, make sure to ask that `cmake` be made available from the command line. Please choose a recent version of cmake.</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;- Create a subdirectory within simdjson, such as `VisualStudio`.</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;- Using a shell, go to this newly created directory.</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;- Type `cmake -DCMAKE_GENERATOR_PLATFORM=x64 ..` in the shell while in the `VisualStudio` repository. (Alternatively, if you want to build a DLL, you may use the command line `cmake -DCMAKE_GENERATOR_PLATFORM=x64 -DSIMDJSON_BUILD_STATIC=OFF ..`.)</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;- This last command (`cmake ...`) created a Visual Studio solution file in the newly created directory (e.g., `simdjson.sln`). Open this file in Visual Studio. You should now be able to build the project and run the tests. For example, in the `Solution Explorer` window (available from the `View` menu), right-click `ALL_BUILD` and select `Build`. To test the code, still in the `Solution Explorer` window, select `RUN_TESTS` and select `Build`.</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;## Usage (Using `vcpkg` on 64-bit Windows, Linux and macOS)</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;[vcpkg](https://github.com/Microsoft/vcpkg) users on Windows, Linux and macOS can download and install `simdjson` with one single command from their favorite shell.</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;On 64-bit Linux and macOS:</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;```</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;$ ./vcpkg install simdjson</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;```</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;will build and install `simdjson` as a static library.</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;On Windows (64-bit):</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;```</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;.\vcpkg.exe install simdjson:x64-windows</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;```</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;will build and install `simdjson` as a shared library.</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;```</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;.\vcpkg.exe install simdjson:x64-windows-static  </div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;```</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;will build and install `simdjson` as a static library.</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;These commands will also print out instructions on how to use the library from MSBuild or CMake-based projects.</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;If you find the version of `simdjson` shipped with `vcpkg` is out-of-date, feel free to report it to `vcpkg` community either by submitting an issue or by creating a PR.</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;## Tools</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;- `json2json mydoc.json` parses the document, constructs a model and then dumps back the result to standard output.</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;- `json2json -d mydoc.json` parses the document, constructs a model and then dumps model (as a tape) to standard output. The tape format is described in the accompanying file `tape.md`.</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;- `minify mydoc.json` minifies the JSON document, outputting the result to standard output. Minifying means to remove the unneeded white space characters.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;- `jsonpointer mydoc.json &lt;jsonpath&gt; &lt;jsonpath&gt; ... &lt;jsonpath&gt;` parses the document, constructs a model and then processes a series of [JSON Pointer paths](https://tools.ietf.org/html/rfc6901). The result is itself a JSON document.</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;## Scope</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;We provide a fast parser, that fully validates an input according to various specifications.</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;The parser builds a useful immutable (read-only) DOM (document-object model) which can be later accessed.</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;To simplify the engineering, we make some assumptions.</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;- We support UTF-8 (and thus ASCII), nothing else (no Latin, no UTF-16). We do not believe this is a genuine limitation, because we do not think there is any serious application that needs to process JSON data without an ASCII or UTF-8 encoding. If the UTF-8 contains a leading BOM, it should be omitted: the user is responsible for detecting and skipping the BOM; UTF-8 BOMs are discouraged.</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;- All strings in the JSON document may have up to 4294967295 bytes in UTF-8 (4GB). To enforce this constraint, we refuse to parse a document that contains more than 4294967295 bytes (4GB). This should accommodate most JSON documents.</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;- As allowed by the specification, we allow repeated keys within an object (other parsers like sajson do the same).</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;- Performance is optimized for JSON documents spanning at least a tens kilobytes up to many megabytes: the performance issues with having to parse many tiny JSON documents or one truly enormous JSON document are different.</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;_We do not aim to provide a general-purpose JSON library._ A library like RapidJSON offers much more than just parsing, it helps you generate JSON and offers various other convenient functions. We merely parse the document.</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;## Features</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;- The input string is unmodified. (Parsers like sajson and RapidJSON use the input string as a buffer.)</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;- We parse integers and floating-point numbers as separate types which allows us to support large signed 64-bit integers in [-9223372036854775808,9223372036854775808), like a Java `long` or a C/C++ `long long` and large unsigned integers up to the value 18446744073709551615. Among the parsers that differentiate between integers and floating-point numbers, not all support 64-bit integers. (For example, sajson rejects JSON files with integers larger than or equal to 2147483648. RapidJSON will parse a file containing an overly long integer like 18446744073709551616 as a floating-point number.) When we cannot represent exactly an integer as a signed or unsigned 64-bit value, we reject the JSON document.</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;- We support the full range of 64-bit floating-point numbers (binary64). The values range from ` std::numeric_limits&lt;double&gt;::lowest()`  to `std::numeric_limits&lt;double&gt;::max()`, so from -1.7976e308 all the way to 1.7975e308. Extreme values (less or equal to -1e308, greater or equal to 1e308) are rejected: we refuse to parse the input document.</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;- We test for accurate float parsing with a bound on the [unit of least precision (ULP)](https://en.wikipedia.org/wiki/Unit_in_the_last_place) of one. Practically speaking, this implies 15 digits of accuracy or better.</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;- We do full UTF-8 validation as part of the parsing. (Parsers like fastjson, gason and dropbox json11 do not do UTF-8 validation. The sajson parser does incomplete UTF-8 validation, accepting code point</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;sequences like 0xb1 0x87.)</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;- We fully validate the numbers. (Parsers like gason and ultranjson will accept `[0e+]` as valid JSON.)</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;- We validate string content for unescaped characters. (Parsers like fastjson and ultrajson accept unescaped line breaks and tabs in strings.)</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;- We fully validate the white-space characters outside of the strings. Parsers like RapidJSON will accept JSON documents with null characters outside of strings.</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;## Architecture</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;The parser works in two stages:</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;- Stage 1. (Find marks) Identifies quickly structure elements, strings, and so forth. We validate UTF-8 encoding at that stage.</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;- Stage 2. (Structure building) Involves constructing a &quot;tree&quot; of sort (materialized as a tape) to navigate through the data. Strings and numbers are parsed at this stage.</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;## JSON Pointer</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;We can navigate the parsed JSON using JSON Pointers as per the [RFC6901 standard](https://tools.ietf.org/html/rfc6901).</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;You can build a tool (jsonpointer) to parse a JSON document and then issue an array of JSON Pointer queries:</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;```</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;make jsonpointer</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; ./jsonpointer jsonexamples/small/demo.json /Image/Width /Image/Height /Image/IDs/2</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160; ./jsonpointer jsonexamples/twitter.json /statuses/0/id /statuses/1/id /statuses/2/id /statuses/3/id /statuses/4/id /statuses/5/id</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;```</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;In C++, given a `document::parser`, we can move to a node with the `move_to` method, passing a `std::string` representing the JSON Pointer query.</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;## Navigating the parsed document</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;From a `simdjson::document::parser` instance, you can create an iterator (of type `simdjson::document::parser::Iterator` which is in fact `simdjson::document::parser::BasicIterator&lt;DEFAULT_MAX_DEPTH&gt;` ) via a constructor:</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;```</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;document::parser::Iterator pjh(parser); // parser is a ParsedJSON</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;```</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;You then have access to the following methods on the resulting `simdjson::document::parser::Iterator`  instance:</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;* `bool is_ok() const`: whether you have a valid iterator, will be false if your parent parsed document::parser is not a valid JSON.</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;* `size_t get_depth() const`:  returns the current depth (start at 1 with 0 reserved for the fictitious root node)</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;* `int8_t get_scope_type() const`: a scope is a series of nodes at the same depth, typically it is either an object (`{`) or an array (`[`). The root node has type &#39;r&#39;.</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;* `bool move_forward()`:  move forward in document order</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;* `uint8_t get_type() const`: retrieve the character code of what we&#39;re looking at: `[{&quot;slutfn` are the possibilities</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;* `int64_t get_integer() const`: get the int64_t value at this node; valid only if get_type() is &quot;l&quot;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;* `uint64_t get_unsigned_integer() const`: get the value as uint64; valid only if get_type() is &quot;u&quot;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;* `const char *get_string() const`: get the string value at this node (NULL ended); valid only if get_type()  is &quot;, note that tabs, and line endings are escaped in the returned value, return value is valid UTF-8, it may contain NULL chars, get_string_length() determines the true string length.</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;* `uint32_t get_string_length() const`: return the length of the string in bytes</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;* `double get_double() const`: get the double value at this node; valid only if gettype() is &quot;d&quot;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;* `bool is_object_or_array() const`: self-explanatory</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;* `bool is_object() const`: self-explanatory</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;* `bool is_array() const`: self-explanatory</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;* `bool is_string() const`: self-explanatory</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;* `bool is_integer() const`: self-explanatory</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;* `bool is_unsigned_integer() const`: Returns true if the current type of node is an unsigned integer. You can get its value with `get_unsigned_integer()`. Only a large value, which is out of range of a 64-bit signed integer, is represented internally as an unsigned node. On the other hand, a typical positive integer, such as 1, 42, or 1000000, is as a signed node. Be aware this function returns false for a signed node.</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;* `bool is_double() const`: self-explanatory</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;* `bool is_number() const`: self-explanatory</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;* `bool is_true() const`: self-explanatory</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;* `bool is_false() const`: self-explanatory</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;* `bool is_null() const`: self-explanatory</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;* `bool is_number() const`: self-explanatory</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;* `bool move_to_key(const char *key)`: when at {, go one level deep, looking for a given key, if successful, we are left pointing at the value, if not, we are still pointing at the object ({)  (in case of repeated keys, this only finds the first one). We seek the key using C&#39;s strcmp so if your JSON strings contain NULL chars, this would trigger a false positive: if you expect that to be the case, take extra precautions. Furthermore, we do the comparison character-by-character without taking into account Unicode equivalence.</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;* `bool move_to_key_insensitive(const char *key)`: as above, but case insensitive lookup </div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;* `bool move_to_key(const char *key, uint32_t length)`: as above except that the target can contain NULL characters</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;* `void move_to_value()`: when at a key location within an object, this moves to the accompanying, value (located next to it).  This is equivalent but much faster than calling `next()`.</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;* `bool move_to_index(uint32_t index)`: when at `[`, go one level deep, and advance to the given index, if successful, we are left pointing at the value,i f not, we are still pointing at the array</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;* `bool move_to(const char *pointer, uint32_t length)`: Moves the iterator to the value correspoding to the json pointer. Always search from the root of the document. If successful, we are left pointing at the value, if not, we are still pointing the same value we were pointing before the call. The json pointer follows the rfc6901 standard&#39;s syntax: https://tools.ietf.org/html/rfc6901</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;* `bool move_to(const std::string &amp;pointer) `: same as above but with a std::string parameter</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;* `bool next()`:   Within a given scope (series of nodes at the same depth within either an array or an object), we move forward. Thus, given [true, null, {&quot;a&quot;:1}, [1,2]], we would visit true, null, { and [. At the object ({) or at the array ([), you can issue a &quot;down&quot; to visit their content. valid if we&#39;re not at the end of a scope (returns true).</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;* `bool prev()`:  Within a given scope (series of nodes at the same depth within either an</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;   array or an object), we move backward.</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;* `bool up()`:  moves back to either the containing array or object (type { or [) from within a contained scope.</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;* `bool down()`: moves us to start of that deeper scope if it not empty. Thus, given [true, null, {&quot;a&quot;:1}, [1,2]], if we are at the { node, we would move to the &quot;a&quot; node.</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;* `void to_start_scope()`: move us to the start of our current scope, a scope is a series of nodes at the same level</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;* `void rewind()`: repeatedly calls up until we are at the root of the document</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;* `bool print(std::ostream &amp;os, bool escape_strings = true) const`: print the node we are currently pointing at</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;Here is a code sample to dump back the parsed JSON to a string:</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;```c++</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    document::parser::Iterator pjh(parser);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    if (!pjh.is_ok()) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      std::cerr &lt;&lt; &quot; Could not iterate parsed result. &quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      return EXIT_FAILURE;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    }</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    compute_dump(parser);</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    //</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    // where compute_dump is :</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;void compute_dump(document::parser::Iterator &amp;pjh) {</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  if (pjh.is_object()) {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    std::cout &lt;&lt; &quot;{&quot;;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    if (pjh.down()) {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      pjh.print(std::cout); // must be a string</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;      std::cout &lt;&lt; &quot;:&quot;;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      pjh.next();</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      compute_dump(pjh); // let us recurse</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      while (pjh.next()) {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        std::cout &lt;&lt; &quot;,&quot;;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        pjh.print(std::cout);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        std::cout &lt;&lt; &quot;:&quot;;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        pjh.next();</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        compute_dump(pjh); // let us recurse</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      }</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      pjh.up();</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    std::cout &lt;&lt; &quot;}&quot;;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  } else if (pjh.is_array()) {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    std::cout &lt;&lt; &quot;[&quot;;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    if (pjh.down()) {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;      compute_dump(pjh); // let us recurse</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;      while (pjh.next()) {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        std::cout &lt;&lt; &quot;,&quot;;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        compute_dump(pjh); // let us recurse</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;      }</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      pjh.up();</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    std::cout &lt;&lt; &quot;]&quot;;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  } else {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    pjh.print(std::cout); // just print the lone value</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  }</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;}</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;```</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;The following function will find all user.id integers:</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;```c++</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;void simdjson_scan(std::vector&lt;int64_t&gt; &amp;answer, document::parser::Iterator &amp;i) {</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;   while(i.move_forward()) {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;     if(i.get_scope_type() == &#39;{&#39;) {</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;       bool found_user = (i.get_string_length() == 4) &amp;&amp; (memcmp(i.get_string(), &quot;user&quot;, 4) == 0);</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;       i.move_to_value();</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;       if(found_user) {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;          if(i.is_object() &amp;&amp; i.move_to_key(&quot;id&quot;,2)) {</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            if (i.is_integer()) {</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;              answer.push_back(i.get_integer());</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            }</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;            i.up();</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;          }</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;       }</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;     }</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;   }</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;}</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;```</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;## In-depth comparisons</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;If you want to see how a wide range of parsers validate a given JSON file:</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;```</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;make allparserscheckfile</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;./allparserscheckfile myfile.json</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;```</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;For performance comparisons:</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;```</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;make parsingcompetition</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;./parsingcompetition myfile.json</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;```</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;For broader comparisons:</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;```</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;make allparsingcompetition</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;./allparsingcompetition myfile.json</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;```</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;Both the `parsingcompetition` and `allparsingcompetition` tools take a `-t` flag which produces</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;a table-oriented output that can be conventiently parsed by other tools.</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;## Docker</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;One can run tests and benchmarks using docker. It especially makes sense under Linux. A privileged access may be needed to get performance counters.</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;```</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;git clone https://github.com/lemire/simdjson.git</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;cd simdjson</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;docker build -t simdjson .</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;docker run --privileged -t simdjson</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;```</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;## Other programming languages</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;We distinguish between &quot;bindings&quot; (which just wrap the C++ code) and a port to another programming language (which reimplements everything).</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;- [ZippyJSON](https://github.com/michaeleisel/zippyjson): Swift bindings for the simdjson project.</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;- [pysimdjson](https://github.com/TkTech/pysimdjson): Python bindings for the simdjson project.</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;- [simdjson-rs](https://github.com/Licenser/simdjson-rs): Rust port.</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;- [simdjson-rust](https://github.com/SunDoge/simdjson-rust): Rust wrapper (bindings).</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;- [SimdJsonSharp](https://github.com/EgorBo/SimdJsonSharp): C# version for .NET Core (bindings and full port).</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;- [simdjson_nodejs](https://github.com/luizperes/simdjson_nodejs): Node.js bindings for the simdjson project.</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;- [simdjson_php](https://github.com/crazyxman/simdjson_php): PHP bindings for the simdjson project.</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;- [simdjson_ruby](https://github.com/saka1/simdjson_ruby): Ruby bindings for the simdjson project.</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;- [simdjson-go](https://github.com/minio/simdjson-go): Go port using Golang assembly.</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;- [rcppsimdjson](https://github.com/eddelbuettel/rcppsimdjson): R bindings.</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;## Various References</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;- [Google double-conv](https://github.com/google/double-conversion/)</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;- [How to implement atoi using SIMD?](https://stackoverflow.com/questions/35127060/how-to-implement-atoi-using-simd)</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;- [Parsing JSON is a Minefield ](http://seriot.ch/parsing_json.php)</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;- https://tools.ietf.org/html/rfc7159</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;- The Mison implementation in rust https://github.com/pikkr/pikkr</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;- http://rapidjson.org/md_doc_sax.html</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;- https://github.com/Geal/parser_benchmarks/tree/master/json</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;- Gron: A command line tool that makes JSON greppable https://news.ycombinator.com/item?id=16727665</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;- GoogleGson https://github.com/google/gson</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;- Jackson https://github.com/FasterXML/jackson</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;- https://www.yelp.com/dataset_challenge</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;- RapidJSON. http://rapidjson.org/</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;Inspiring links:</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;- https://auth0.com/blog/beating-json-performance-with-protobuf/</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;- https://gist.github.com/shijuvar/25ad7de9505232c87034b8359543404a</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;- https://github.com/frankmcsherry/blog/blob/master/posts/2018-02-11.md</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;Validating UTF-8 takes no more than 0.7 cycles per byte:</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;- https://github.com/lemire/fastvalidate-utf-8 https://lemire.me/blog/2018/05/16/validating-utf-8-strings-using-as-little-as-0-7-cycles-per-byte/</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;## Remarks on JSON parsing</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;- The JSON spec defines what a JSON parser is:</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  &gt; A JSON parser transforms a JSON text into another representation. A JSON parser MUST accept all texts that conform to the JSON grammar. A JSON parser MAY accept non-JSON forms or extensions. An implementation may set limits on the size of texts that it accepts. An implementation may set limits on the maximum depth of nesting. An implementation may set limits on the range and precision of numbers. An implementation may set limits on the length and character contents of strings.</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;* JSON is not JavaScript:</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  &gt; All JSON is Javascript but NOT all Javascript is JSON. So {property:1} is invalid because property does not have double quotes around it. {&#39;property&#39;:1} is also invalid, because it&#39;s single quoted while the only thing that can placate the JSON specification is double quoting. JSON is even fussy enough that {&quot;property&quot;:.1} is invalid too, because you should have of course written {&quot;property&quot;:0.1}. Also, don&#39;t even think about having comments or semicolons, you guessed it: they&#39;re invalid. (credit:https://github.com/elzr/vim-json)</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;* The structural characters are:</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      begin-array     =  [ left square bracket</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      begin-object    =  { left curly bracket</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      end-array       =  ] right square bracket</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      end-object      =  } right curly bracket</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      name-separator  = : colon</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      value-separator = , comma</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;### Pseudo-structural elements</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;A character is pseudo-structural if and only if:</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;1. Not enclosed in quotes, AND</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;2. Is a non-whitespace character, AND</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;3. Its preceding character is either:</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;   (a) a structural character, OR</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;   (b) whitespace.</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;This helps as we redefine some new characters as pseudo-structural such as the characters 1, G, n in the following:</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;&gt; { &quot;foo&quot; : 1.5, &quot;bar&quot; : 1.5 GEOFF_IS_A_DUMMY bla bla , &quot;baz&quot;, null }</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;## Academic References</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;- T.Mhlbauer, W.Rdiger, R.Seilbeck, A.Reiser, A.Kemper, and T.Neumann. Instant loading for main memory databases. PVLDB, 6(14):17021713, 2013. (SIMD-based CSV parsing)</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;- Mytkowicz, Todd, Madanlal Musuvathi, and Wolfram Schulte. &quot;Data-parallel finite-state machines.&quot; ACM SIGARCH Computer Architecture News. Vol. 42. No. 1. ACM, 2014.</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;- Lu, Yifan, et al. &quot;Tree structured data processing on GPUs.&quot; Cloud Computing, Data Science &amp; Engineering-Confluence, 2017 7th International Conference on. IEEE, 2017.</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;- Sidhu, Reetinder. &quot;High throughput, tree automata based XML processing using FPGAs.&quot; Field-Programmable Technology (FPT), 2013 International Conference on. IEEE, 2013.</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;- Dai, Zefu, Nick Ni, and Jianwen Zhu. &quot;A 1 cycle-per-byte XML parsing accelerator.&quot; Proceedings of the 18th annual ACM/SIGDA international symposium on Field programmable gate arrays. ACM, 2010.</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;- Lin, Dan, et al. &quot;Parabix: Boosting the efficiency of text processing on commodity processors.&quot; High Performance Computer Architecture (HPCA), 2012 IEEE 18th International Symposium on. IEEE, 2012. http://parabix.costar.sfu.ca/export/1783/docs/HPCA2012/final_ieee/final.pdf</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;- Deshmukh, V. M., and G. R. Bamnote. &quot;An empirical evaluation of optimization parameters in XML parsing for performance enhancement.&quot; Computer, Communication and Control (IC4), 2015 International Conference on. IEEE, 2015.</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;- Moussalli, Roger, et al. &quot;Efficient XML Path Filtering Using GPUs.&quot; ADMS@ VLDB. 2011.</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;- Jianliang, Ma, et al. &quot;Parallel speculative dom-based XML parser.&quot; High Performance Computing and Communication &amp; 2012 IEEE 9th International Conference on Embedded Software and Systems (HPCC-ICESS), 2012 IEEE 14th International Conference on. IEEE, 2012.</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;- Li, Y., Katsipoulakis, N.R., Chandramouli, B., Goldstein, J. and Kossmann, D., 2017. Mison: a fast JSON parser for data analytics. Proceedings of the VLDB Endowment, 10(10), pp.1118-1129. http://www.vldb.org/pvldb/vol10/p1118-li.pdf</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;- Cameron, Robert D., et al. &quot;Parallel scanning with bitstream addition: An xml case study.&quot; European Conference on Parallel Processing. Springer, Berlin, Heidelberg, 2011.</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;- Cameron, Robert D., Kenneth S. Herdy, and Dan Lin. &quot;High performance XML parsing using parallel bit stream technology.&quot; Proceedings of the 2008 conference of the center for advanced studies on collaborative research: meeting of minds. ACM, 2008.</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;- Shah, Bhavik, et al. &quot;A data parallel algorithm for XML DOM parsing.&quot; International XML Database Symposium. Springer, Berlin, Heidelberg, 2009.</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;- Cameron, Robert D., and Dan Lin. &quot;Architectural support for SWAR text processing with parallel bit streams: the inductive doubling principle.&quot; ACM Sigplan Notices. Vol. 44. No. 3. ACM, 2009.</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;- Amagasa, Toshiyuki, Mana Seino, and Hiroyuki Kitagawa. &quot;Energy-Efficient XML Stream Processing through Element-Skipping Parsing.&quot; Database and Expert Systems Applications (DEXA), 2013 24th International Workshop on. IEEE, 2013.</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;- Medforth, Nigel Woodland. &quot;icXML: Accelerating Xerces-C 3.1. 1 using the Parabix Framework.&quot; (2013).</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;- Zhang, Qiang Scott. Embedding Parallel Bit Stream Technology Into Expat. Diss. Simon Fraser University, 2010.</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;- Cameron, Robert D., et al. &quot;Fast Regular Expression Matching with Bit-parallel Data Streams.&quot;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;- Lin, Dan. Bits filter: a high-performance multiple string pattern matching algorithm for malware detection. Diss. School of Computing Science-Simon Fraser University, 2010.</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;- Yang, Shiyang. Validation of XML Document Based on Parallel Bit Stream Technology. Diss. Applied Sciences: School of Computing Science, 2013.</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;- N. Nakasato, &quot;Implementation of a parallel tree method on a GPU&quot;, Journal of Computational Science, vol. 3, no. 3, pp. 132-141, 2012.</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;## Funding</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;The work is supported by the Natural Sciences and Engineering Research Council of Canada under grant number RGPIN-2017-03910.</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;[license]: LICENSE</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;[license img]: https://img.shields.io/badge/License-Apache%202-blue.svg</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
